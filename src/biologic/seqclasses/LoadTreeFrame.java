/*
 *  Armadillo Workflow Platform v1.0
 *  A simple pipeline system for phylogenetic analysis
 *  
 *  Copyright (C) 2009-2011  Etienne Lord, Mickael Leclercq
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


package biologic.seqclasses;

import biologic.MultipleTrees;
import biologic.Tree;
import configuration.Config;
import configuration.TreeFilter;
import database.databaseFunction;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.SwingWorker;
import tools.Toolbox;

/**
 * Tree Frame
 * @author Etienne Lord
 */
public class LoadTreeFrame extends javax.swing.JFrame {

    databaseFunction df=new databaseFunction();
    Config config=new Config();       
    InformationJDialog loading;                        //Loading sequence JDialog
    private boolean stateSelected=false;             //do we Select or Unselect
    //This is a list of all the trees in the database
    MultipleTrees MultipleTree=new MultipleTrees();

     ////////////////////////////////////////////////////////////////////////////
    // Constantes
    // Search
    String lastSearch="";
    static final int MODE_ID=0;
    static final int MODE_ACCESSION=1;
    static final int MODE_DESC=2;
    static final int MODE_ALIASES=3;
    static final int MODE_ALL=4;
    static final int MODE_LENMORE=6;
    static final int MODE_LENLESS=7;


    /** Creates new form LoadTreeFrame */
    public LoadTreeFrame() {
        initComponents();
        this.setIconImage(Config.image);
        this.setName("Tree Manager");
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension d = getSize();
        setLocation((screenSize.width-d.width)/2,
					(screenSize.height-d.height)/2);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel3 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jPanel4 = new javax.swing.JPanel();
        Filter_ComboBox = new javax.swing.JComboBox();
        jStatusMessage = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        RemoveSequence_jButton = new javax.swing.JButton();
        MakeCollectionjButton = new javax.swing.JButton();
        Close_jButton = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenuItem3 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItem4 = new javax.swing.JMenuItem();
        SelectUnselectSequence_jMenuItem = new javax.swing.JMenuItem();
        jMenuItem5 = new javax.swing.JMenuItem();

        setTitle("Tree Manager");

        jPanel3.setBackground(new java.awt.Color(255, 255, 255));
        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(""));

        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);

        jTable1.setAutoCreateRowSorter(true);
        jTable1.setModel(new biologic.seqclasses.TreeTableModel());
        jScrollPane1.setViewportView(jTable1);

        jPanel4.setBackground(new java.awt.Color(255, 255, 255));
        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("Filter trees"));

        Filter_ComboBox.setEditable(true);
        Filter_ComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "ALL", "homo_sapiens         [human]", "mus_musculus         [mouse]", "rattus_norvegicus   [rat]" }));
        Filter_ComboBox.setToolTipText("Filter your results. Enter a search string");
        Filter_ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Filter_ComboBoxActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Filter_ComboBox, 0, 608, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(Filter_ComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        jStatusMessage.setForeground(new java.awt.Color(0, 51, 204));
        jStatusMessage.setText("List of the current trees in the project");
        jStatusMessage.setBorder(null);

        jButton1.setText("Select / Unselect");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        RemoveSequence_jButton.setText("Remove");
        RemoveSequence_jButton.setToolTipText("<html>Remove current selected sequences from the database<br></html>");
        RemoveSequence_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RemoveSequence_jButtonActionPerformed(evt);
            }
        });

        MakeCollectionjButton.setText("Make Group");
        MakeCollectionjButton.setToolTipText("This will make a new Collection from the selected sequence");
        MakeCollectionjButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MakeCollectionjButtonActionPerformed(evt);
            }
        });

        Close_jButton.setText("Close");
        Close_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Close_jButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jStatusMessage, javax.swing.GroupLayout.PREFERRED_SIZE, 624, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(RemoveSequence_jButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 266, Short.MAX_VALUE)
                        .addComponent(MakeCollectionjButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Close_jButton, javax.swing.GroupLayout.PREFERRED_SIZE, 71, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(12, 12, 12))))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 624, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jStatusMessage, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Close_jButton)
                    .addComponent(MakeCollectionjButton)
                    .addComponent(RemoveSequence_jButton)
                    .addComponent(jButton1)))
        );

        jMenu1.setText("File");

        jMenuItem1.setText("Import from disk");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuItem2.setText("Add new Tree");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem2);

        jMenuItem3.setText("Save selected tree");
        jMenu1.add(jMenuItem3);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");

        jMenuItem4.setText("Remove");
        jMenuItem4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem4RemoveSequence_jButtonActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem4);

        SelectUnselectSequence_jMenuItem.setText("Select/Unselect");
        SelectUnselectSequence_jMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SelectUnselectSequence_jMenuItemActionPerformed(evt);
            }
        });
        jMenu2.add(SelectUnselectSequence_jMenuItem);

        jMenuItem5.setText("Make new group");
        jMenuItem5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem5ActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem5);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, 562, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void Filter_ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Filter_ComboBoxActionPerformed
                //Update the displayed data in the table
                TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
                int mode=this.Filter_ComboBox.getSelectedIndex();
                String search_term=(String)this.Filter_ComboBox.getSelectedItem();
                if (search_term.indexOf("[")>-1) search_term=search_term.substring(0,search_term.indexOf("["));
                search_term=search_term.trim();
                search_term=search_term.replaceAll(" ", "_");
                //DEfault mode is ALL
                if (mode==0) {
                    tm.data.clear();
                    tm.setData(MultipleTree.getTree());
                    Message("Found "+tm.data.size()+"tree(s)","",this.jStatusMessage);
                } else {
                    Vector<Integer> resultIndex=this.search(search_term,MODE_ALL);
                    tm.data.clear();
                    for (Integer index:resultIndex) {
                        tm.addData(MultipleTree.getTree().get(index));
                    }
                    Message("Found "+resultIndex.size()+" tree(s)","",this.jStatusMessage);
                }                        
                tm.fireTableDataChanged();
                this.jTable1.setModel(tm);
}//GEN-LAST:event_Filter_ComboBoxActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
             //Update the displayed data in the table
                TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
            //What do we do?
            int[] index=this.jTable1.getSelectedRows();
            //CAS 1. On met tout a select ou unselect
            if (index.length==0) {
                for (Tree s:tm.data) s.setSelected(stateSelected);
                stateSelected=!stateSelected;
            } else {
                //CAS 2. Inversion de la sélection
                for (int i:index) {
                    i=this.jTable1.convertRowIndexToModel(i);
                    tm.data.get(i).setSelected(!tm.data.get(i).isSelected());
                    //Locate ture data
        
                }
        
            }
        
            tm.fireTableDataChanged();
            this.jTable1.setModel(tm);
}//GEN-LAST:event_jButton1ActionPerformed

    private void RemoveSequence_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RemoveSequence_jButtonActionPerformed
        TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
        //What do we do?
        //--First get the right selection
//        int[] indexSelection=this.jTable1.getSelectedRows();
//        for (int i=0;i<indexSelection.length;i++) {
//            indexSelection[i]=this.jTable1.convertRowIndexToModel(indexSelection[i]);
//        }
        //--Ok, by default, if we have a selection (but not checked, we remove the selection...
        String msg="<html>Do you really want to remove "+getNumberSelected()
                +" trees from database?</html>";
        Object[] options = {"Yes","Cancel"};
        int choice = JOptionPane.showOptionDialog(this,msg,"Warning! Remove Tree from Project",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options, options[0]);
        //choice==0 [YES] We remove
        if (choice==0) {
            //Case 1: we remove the current displayed selected sequence
//            if (indexSelection.length>0) {
//                //Mark for remove
//                for (Integer i:indexSelection) {
//                    Tree s=MultipleTree.getTree().get(i);
//                    s.setSelected_for_remove(true);
//                }
//
//            }
//            //Case 2: No selection: remove all selected sequence
//            else {
                for (Tree s:MultipleTree.getTree()) if (s.isSelected()) s.setSelected_for_remove(true);
//            }

            //Actual remove
            Vector<Tree> toRemove=new Vector<Tree>();
            for (int i=MultipleTree.getTree().size()-1;i>-1;i--) {
               Tree s=MultipleTree.getTree().get(i);
                if (s.isSelected_for_remove()) {
                    toRemove.add(s);
                }
            }
            RemoveTrees(toRemove);

      } //End choice ==0 We remove
}//GEN-LAST:event_RemoveSequence_jButtonActionPerformed

    private void MakeCollectionjButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MakeCollectionjButtonActionPerformed
        makeGroup();
}//GEN-LAST:event_MakeCollectionjButtonActionPerformed

    private void Close_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Close_jButtonActionPerformed
        for (Tree info:this.MultipleTree.getTree()) {
            if (info.isModified()) {
               info.updateDatabase();
            }
        }
        Toolbox tool=new Toolbox();
        tool.reloadDatabaseTree();
        this.setVisible(false);
}//GEN-LAST:event_Close_jButtonActionPerformed

    private void jMenuItem4RemoveSequence_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem4RemoveSequence_jButtonActionPerformed
        TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
        //What do we do?
        //--First get the right selection
        int[] indexSelection=this.jTable1.getSelectedRows();
        for (int i=0;i<indexSelection.length;i++) {
            indexSelection[i]=this.jTable1.convertRowIndexToModel(indexSelection[i]);
        }
        //--Ok, by default, if we have a selection (but not checked, we remove the selection...
        String msg="<html>Do you really want to remove "+(indexSelection.length>0?indexSelection.length:getNumberSelected())
                +" tree(s) from database?</html>";
        Object[] options = {"Yes","Cancel"};
        int choice = JOptionPane.showOptionDialog(this,msg,"Warning! Remove Tree from Project",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options, options[0]);
        //choice==0 [YES] We remove
        if (choice==0) {
            //Case 1: we remove the current displayed selected sequence
            if (indexSelection.length>0) {
                //Mark for remove
                for (Integer i:indexSelection) {
                    Tree s=MultipleTree.getTree().get(i);
                    s.setSelected_for_remove(true);
                }

            }
            //Case 2: No selection: remove all selected sequence
            else {
                for (Tree s:MultipleTree.getTree()) if (s.isSelected()) s.setSelected_for_remove(true);
            }

            //Actual remove
            Vector<Tree> toRemove=new Vector<Tree>();
            for (int i=MultipleTree.getNbTrees()-1;i>-1;i--) {
                Tree s=MultipleTree.getTree().get(i);
                if (s.isSelected_for_remove()) {
                    toRemove.add(s);
                }
            }
            RemoveTrees(toRemove);
        } //End choice ==0 We remove
}//GEN-LAST:event_jMenuItem4RemoveSequence_jButtonActionPerformed

     /**
     * This display the sequence box
     */
    public void display() {
        //--Get the number of tree
        Tree t=new Tree();
        t.hasNext();
        //--Reload sequence if no trees loadded or new tree added...
        
        if (MultipleTree.getNbTrees()==0||MultipleTree.getNbTrees()!=t.getAllId().size()) loadTree();
         setVisible(true);
    }

    private void loadTree() {
      MultipleTree.getTree().clear();
      final Vector<Integer>tree_id=df.getAllTreeID();
      final int size=tree_id.size();
      SwingWorker<Integer, Tree> infoSwingWorker=new SwingWorker<Integer, Tree>()  {

       @Override
        protected Integer doInBackground() throws Exception {
        try {
            for (int i=0; i<size;i++) {
               Tree info=new Tree(tree_id.get(i));
               publish(info);
               setProgress(i*100/size);
            }
        } catch(Exception e) {e.printStackTrace();}
                return 0;
            }

            //On update notre Table avec les resultats partiels
            @Override
            protected void process(List<Tree> chunks) {
                for (Tree data:chunks) {
                    MultipleTree.add(data);
                }
            }


           @Override
           protected void done(){
                loading.setVisible(false);
                updateUI();
           }

        }; //End SwingWorker declaration

        infoSwingWorker.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                     if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        loading=new InformationJDialog(this, false, infoSwingWorker, "Loading tree(s)");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Loading "+size+" Tree information from database...", "");
        infoSwingWorker.execute();
    }

    private void RemoveTrees(final Vector<Tree> toRemove) {
      final int size=toRemove.size();
      SwingWorker<Integer, Tree> infoSwingWorker=new SwingWorker<Integer, Tree>()  {

       @Override
        protected Integer doInBackground() throws Exception {
            //--Commit only at the end...
            df.setAutoCommit(false);
            for(int i=0; i<size;i++) {
                Tree tmp=toRemove.get(i);
                tmp.removeFromDatabase();
                publish(tmp);
                setProgress(i*100/size);
            }
            df.setAutoCommit(true);
            return 0;
            }

            //Update list of InfoSequence
            @Override
            protected void process(List<Tree> chunks) {
                for (Tree tmp:chunks) MultipleTree.getTree().remove(tmp);
            }


           @Override
           protected void done(){
                loading.setVisible(false);
                loadTree();
                
           }

        }; //End SwingWorker declaration

        infoSwingWorker.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                     if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        loading=new InformationJDialog(this, false, infoSwingWorker, "Removing sequence(s)");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Removing "+size+" sequence(s) from database...", "");
        infoSwingWorker.execute();
    }

     public void makeGroup() {
         TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();

                for (Tree t:this.MultipleTree.getTree()) if (t.isSelected()) t.setSelected_for_grouping(true);


        StandardInputSequenceJDialog jd=new StandardInputSequenceJDialog(this, "New_Group_"+this.hashCode(),"Create","MultipleTrees");
        jd.setVisible(true);
        if (jd.getStatus()==Config.status_done) {
            MultipleTrees multi=new MultipleTrees();
            multi.setName(jd.getCollectionName());
            multi.setNote(jd.getComments());
            for (Tree s:this.MultipleTree.getTree()) {
                if (s.isSelected_for_grouping()) multi.add(s);
            }
            for (Tree s:this.MultipleTree.getTree()) s.setSelected_for_grouping(false);
            multi.saveToDatabase();
            updateUI();
        }
    }

/**
 * This function load all the trees in the database and
 * display them in the JTable
 */
public void updateUI() {
   
    //--Put them in the table
       TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
       tm.data.clear();
       tm.setData(MultipleTree.getTree());
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
    //--Display some information
    Message("Currently "+MultipleTree.getNbTrees()+" sequences in database.","", this.jStatusMessage);
    //Put group information in filter ComboBox;
    this.Filter_ComboBox.setModel(new DefaultComboBoxModel(Config.ClusteringOption));
    for (String S: df.getTreeGroup()) this.Filter_ComboBox.addItem(S);
}

     /**
     * Affiche un message dans la status bar
     * La provenance peut être mise dans un tooltip
     * @param text Le texte
     * @param tooltip Le tooltip texte
     */
    void Message(String text, String tooltip, JTextField jStatusMessage) {
        jStatusMessage.setEnabled(true);
        jStatusMessage.setForeground(new java.awt.Color(0, 51, 153));
        jStatusMessage.setBackground(Color.WHITE);
        jStatusMessage.setToolTipText(tooltip);
        jStatusMessage.setText(text);
    }

    /**
     * Affiche un message d'erreur en rouge dans la status bar
     * La provenance peut être mise dans un tooltip
     * @param text Le texte
     * @param tooltip Le tooltip texte
     */
    void MessageError(String text, String tooltip, JTextField jStatusMessage) {
        jStatusMessage.setEnabled(true);
        jStatusMessage.setForeground(Color.RED);
        jStatusMessage.setBackground(Color.WHITE);
        jStatusMessage.setToolTipText(tooltip);
        jStatusMessage.setText(text);
    }

    private void SelectUnselectSequence_jMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SelectUnselectSequence_jMenuItemActionPerformed
        TreeTableModel tm=(TreeTableModel)this.jTable1.getModel();
        //What do we do?
        int[] index=this.jTable1.getSelectedRows();
        //CAS 1. On met tout a select ou unselect
        if (index.length==0) {
            for (Tree s:tm.data) s.setSelected(stateSelected);
            stateSelected=!stateSelected;
        } else {
            //CAS 2. Inversion de la sélection
            for (int i:index) {
                i=this.jTable1.convertRowIndexToModel(i);
                tm.data.get(i).setSelected(!tm.data.get(i).isSelected());
            }

        }
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
}//GEN-LAST:event_SelectUnselectSequence_jMenuItemActionPerformed

    private void jMenuItem5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem5ActionPerformed
        // TODO add your handling code here:
}//GEN-LAST:event_jMenuItem5ActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        JFileChooser jf=new JFileChooser(config.getExplorerPath());
        jf.setMultiSelectionEnabled(true);
        jf.addChoosableFileFilter(new TreeFilter());
        jf.setAcceptAllFileFilterUsed(false);
        int result=jf.showOpenDialog(this);
        //CAS 1: On reussi a choisir un fichier
        if (result==JFileChooser.APPROVE_OPTION) {
             String path=jf.getSelectedFile().getPath();
             config.setExplorerPath(path);
            File[] files=jf.getSelectedFiles();
            if (files.length>0) {
                String filename="";
                if (files.length==1) {
                    filename=files[0].getName()+"_"+this.hashCode();
                } else {
                    filename="Multiple_tree_"+this.hashCode();
                }
                StandardInputSequenceJDialog jd=new StandardInputSequenceJDialog(this, filename,"Import Tree", "Tree");
                jd.setVisible(true);
                if (jd.getStatus()==Config.status_done) {
                    loadTreeFiles(files,jd.getCollectionName(),jd.getComments());//load Files using a Swing worker
                }
            }
        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
       SimpleInputJDialog si=new SimpleInputJDialog(this, true, "Tree");
       if (si.isAdded()) this.loadTree();
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    /**
     * Simple thread to load file into the project
     */
    private void loadTreeFiles(final File[] files, final String groupname, final String note) {
        final LinkedList<File> toLoad=new LinkedList<File>();
        final int totalToLoad=files.length;
        for(File f:files) toLoad.add(f);

        SwingWorker<Integer, Object> loadSwingWorker2=new SwingWorker<Integer, Object>() {
            String filename="";

            @Override
            protected Integer doInBackground() throws Exception {
                //We dont check for cancelled

                while (!isCancelled()&&toLoad.size()>0) {
                    File f=toLoad.pollFirst();
                    filename=f.getAbsolutePath();
                    publish("Loading "+filename);
                    MultipleTrees multi=new MultipleTrees();
                    multi.setName(groupname);
                    multi.readNewick(filename);
                    multi.setNote(note);                     
                    int index=1;
                    for (Tree t:multi.getTree()) t.setName(filename+"_"+index++);
                    multi.saveToDatabase();
                    setProgress((totalToLoad-toLoad.size())*100/totalToLoad);
                    if (multi.getId()==0) {
                        publish("Unable to load tree from "+filename);
                    } else {
                        publish("Successfully imported tree from "+filename);
                    }
                 }
                return 0;
            }

            @Override
            public void process(List<Object> chunk) {
                for (Object o:chunk) {
                    if (o instanceof String)  {
                        String s=(String)o;
                        if (s.startsWith("Unable")||s.startsWith("Error")) {
                            loading.MessageErreur(s, "");
                        } else {
                            loading.Message(s,"");
                        } //--End Unable
                     } //--End instance of String
                } //--End list of Object
            } //End process

            @Override
            public void done() {
                loading.setVisible(false);
                //Update UI by reloading alll sequences... (to be sure)...
                loadTree();
            }

        }; //End SwingWorker definition

        loadSwingWorker2.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                        if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        //Finally. Show a load dialog :: Warning Work-In-Progress
        loading=new InformationJDialog(this, false, loadSwingWorker2,"");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Loading "+files.length+" files...", "");
        loadSwingWorker2.execute();
    }

     /**
     *
     * @return the number of Selected Sequence
     */
    public int getNumberSelected() {
        int number=0;
        for (Tree s:MultipleTree.getTree()) {
            if (s.isSelected()) number++;
        }
        return number;
    }

    Vector<Integer> search (String regex, int mode) {
        Vector<Integer> returnArray = new Vector<Integer>();
        Pattern p;
        try {
            p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
        } catch(java.util.regex.PatternSyntaxException e) {return returnArray;}
        int search_len=0;
        try {
            search_len=Integer.valueOf(regex);
        } catch (Exception e) {search_len=0;}
        switch (mode) {
            case MODE_ID:       lastSearch="Id with: "+regex;
                                for (int i=0; i<MultipleTree.getTree().size();i++) {
                                      Tree data=MultipleTree.getTree().get(i);
//                                      Matcher m = p.matcher(data.getGi());
//                                      Matcher m2 = p.matcher(data.getAccession());
//                                      if (m.find()||m2.find()) returnArray.add(i);
                                }
                                break;
            case MODE_ACCESSION:lastSearch="Accession with: "+regex;
//                                for (int i=0; i<MultipleInfoSequence.size();i++) {
//                                     InfoSequence data=MultipleInfoSequence.get(i);
//                                      Matcher m = p.matcher(data.getAccession());
//                                      if (m.find()) returnArray.add(i);
//                                }
                                break;
            case MODE_DESC:  lastSearch="Description with: "+regex;
//                                for (int i=0; i<MultipleInfoSequence.size();i++) {
//                                      InfoSequence data=MultipleInfoSequence.get(i);
//                                       Matcher m = p.matcher(data.getName());
//                                      if (m.find()) returnArray.add(i);
//                                }
                                break;
            case MODE_LENMORE: lastSearch="Len(bp) greater: "+regex;
//                                for (int i=0; i<MultipleInfoSequence.size();i++) {
//                                    InfoSequence data=MultipleInfoSequence.get(i);
//                                    try {
//                                        int len=data.getLen();
//                                        if (len>=search_len) returnArray.add(i);
//                                    } catch(Exception e) {}
//                                }
                                break;
             case MODE_LENLESS: lastSearch="Len(bp) greater: "+regex;
//                                for (int i=0; i<MultipleInfoSequence.size();i++) {
//                                    InfoSequence data=MultipleInfoSequence.get(i);
//                                    try {
//                                        int len=Integer.valueOf(data.getLen());
//                                        if (len<=search_len) returnArray.add(i);
//                                    } catch(Exception e) {}
//                                }
                                break;
            case MODE_ALL:      lastSearch="All with: "+regex;
                                for (int i=0; i<MultipleTree.getTree().size();i++) {
                                     Tree data=MultipleTree.getTree().get(i);
                                    Matcher m1 = p.matcher(data.toString());
                                    if (m1.find()) returnArray.add(i);
                                }
        } //end switch
        Config.log("Searching for "+lastSearch);
        System.out.printf(" found %d result(s)\n", returnArray.size());
        return returnArray;
      }
   

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Close_jButton;
    private javax.swing.JComboBox Filter_ComboBox;
    private javax.swing.JButton MakeCollectionjButton;
    private javax.swing.JButton RemoveSequence_jButton;
    private javax.swing.JMenuItem SelectUnselectSequence_jMenuItem;
    private javax.swing.JButton jButton1;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JMenuItem jMenuItem4;
    private javax.swing.JMenuItem jMenuItem5;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jStatusMessage;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables

}
